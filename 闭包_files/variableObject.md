
## 相关概念
### 变量对象：用于存储上下文中声明的对象，如变量，函数声明
1. 全局对象的形式，全局的VO，全局的VO就是全局的对象global
```ruby
VO(globalContext) = {
    a: 10,
    test: <reference to function />
};
```
全局对象是在进入任何上下文之前就已经创建的对象。这个对象只有一份，而且生命周期是在程序退出的那一刻终止。
全局对象在创建的时候会将Math、String、Date、parseInt...作为自身的属性。同时还有window属性是全局对象自身
2. 局部的形式，局部的VO是指的函数上下文的对象，例如：变量、函数、函数形参。见例题一:
```ruby
VO(test functionContext) = {
    x: 30,
    b: 20
};
```
函数上下文中的对象，在函数执行上下文中，VO(function text)指的是AO
AO是在进入函数上下文时刻创建的，通过函数的arguments属性初始化。arguments属性的值是arguments对象。
```ruby
AO = {
    arguments: <Argo>
}
```
3. 处理上下文代码的两个阶段
   1. 进入执行上下文
   创建函数形参:名称和对应的值组成的对象，如果没有值就是undefined
   函数声明：名称和对应的值，组成一个对象，变量对象名如果已经存在，后者会替换前者。
   变量声明：名称和对应的值，组成对象，值如果没有传递就是undefined。
见例题二
+ 执行代码
代码执行期间，会对代码进行修改
```rubu
AO['c'] = 10;
AO['e'] = <reference to FunctionExpression "_e">;
 那么进入上下文时AO如下：
 AO(test) = {
  a: 10,
  b: undefined,
  c: undefined,
  d: <reference to FunctionDeclaration "d">
  e: undefined
};
```
进入上下文时，会根据变量的名称构建AO，x不在AO中是因为这个是函数表达式，_e存在在AO中是因为有变量名称e
那么什么是函数声明？什么是函数表达式？
 4. 命名函数表达式
 + 函数创建的方式: 函数声明和函数表达式
在ECMA规范中明确了一点就是：函数的声明必须带有identifer即函数名称，表达式则可以省略这个。
```ruby
函数声明：
function 函数名称 () {}
函数表达式
function 函数名称(可选))(){}
```
 如果都有函数名称，则根据上下文来判断是函数表达式还是函数声明。如果函数是作为表达式的一部分则是函数表达式。
如果是在函数体内或者是在程序内，则是函数声明
见： 例题三
+ 这两种创建方式的区别
那么函数表达式和函数声明之间有什么区别吗？
第一：函数声明会在任何表达式被解析和求值之前被解析和求值；
见例题四：
+ 注意的问题
函数声明在条件语句中的使用在注意，在block语句块的函数语句，不同的浏览器解析不同，作为函数表达式或者函数声明语句
见例题五
+ 函数命名表达式
什么是函数命名表达式？
函数必须有名字，且是表达式
var f = function foo (){}
函数命名表达式这个名字只能在新生成的函数作用域中访问，不能在外部作用域访问。
见例题六